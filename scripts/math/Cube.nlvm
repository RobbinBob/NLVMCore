package scripts.math;

/// <class>
/// <desc>Represents a Cuboid.</desc>
public class Cube extends Volume
{
    private Matrix4x4 m_UnitScaleMatrix = null;

    public Cube(Matrix4x4 matrix, Vector3 scale)
    {
        super(matrix, scale);
        m_UnitScaleMatrix = Matrix4x4.AsScale(1 / m_VolumeScale.X, 1 / m_VolumeScale.Y, 1 / m_VolumeScale.Z);
    }
    public Cube(Vector3 position, Vector3 rotation, Vector3 scale)
    {
        super();

        m_VolumeMatrix = Matrix4x4.Identity;
        if(position != null)
            m_VolumeMatrix = Matrix4x4.AsTranslation(position);
        if(rotation != null)
            m_VolumeMatrix = m_VolumeMatrix.RightMultiply(Matrix4x4.AsRotation(rotation));
        if(scale != null)
            m_VolumeMatrix = m_VolumeMatrix.RightMultiply(Matrix4x4.AsScale(scale));

        m_VolumeScale = scale == null ? Vector3.One : scale;
        m_UnitScaleMatrix = Matrix4x4.AsScale(1 / m_VolumeScale.X, 1 / m_VolumeScale.Y, 1 / m_VolumeScale.Z);
    }

    private Bounds GetCorners()
    {
        Matrix4x4 matrixInv = m_VolumeMatrix.Invert();
        
        Matrix4x4 localScale = Matrix4x4.AsScale(1.0f / m_VolumeScale.X, 1.0f / m_VolumeScale.Y, 1.0f / m_VolumeScale.Z);
        Matrix4x4 scaledMatrix = m_VolumeMatrix.RightMultiply(localScale); // Seems to bring it back into -1 to 1 range
        Vector3 halfScale = m_VolumeScale.Div(2);

            // Create the minimum corner in local-space
        Vector3 minCorner = halfScale.Copy().Mul(-1);
        minCorner = scaledMatrix.RightMultiply(Matrix4x4.AsTranslation(minCorner)).GetPosition();
        minCorner = matrixInv.Multiply3x3(minCorner);

            // Create the maximum corner in local-space
        Vector3 maxCorner = halfScale.Copy();
        maxCorner = scaledMatrix.RightMultiply(Matrix4x4.AsTranslation(maxCorner)).GetPosition();
        maxCorner = matrixInv.Multiply3x3(maxCorner);

        return new Bounds(minCorner, maxCorner);
    }

    public bool IsPointWithinVolume(Vector3 point)
    {
        Vector3 center = m_VolumeMatrix.GetPosition();
        if(Vector3.Distance(center, point) > m_VolumeScale.Length() / 2.0f)
            return false;


        Matrix4x4 matrixInv = m_VolumeMatrix.Invert();
        Bounds bounds = GetCorners();
        Vector3 minCorner = bounds.Min;
        Vector3 maxCorner = bounds.Max;

            // Pull the world-space point into local-space
        Vector3 localPoint = matrixInv.Multiply3x3(point);
        return localPoint.GreaterThan(minCorner) && localPoint.LessThan(maxCorner);
    }
    public bool IsPointOutsideVolume(Vector3 point)
    {
        Matrix4x4 matrixInv = m_VolumeMatrix.Invert();
        Bounds bounds = GetCorners();
        Vector3 minCorner = bounds.Min;
        Vector3 maxCorner = bounds.Max;

            // Pull the world-space point into local-space
        Vector3 localPoint = matrixInv.Multiply3x3(point);
        return (localPoint.X < minCorner.X || localPoint.Y < minCorner.Y || localPoint.Z < minCorner.Z) ||
                (localPoint.X > maxCorner.X || localPoint.Y > maxCorner.Y || localPoint.Z > maxCorner.Z);
    }
    public Vector3 GetNearestSurface(Vector3 point)
    {
        Matrix4x4 unitScale = m_VolumeMatrix.RightMultiply(m_UnitScaleMatrix);
        Vector3 localSpacePoint = unitScale.Invert().TransformVector3One(point);
        Vector3 halfExtents = m_VolumeScale.Div(2);

        float x = Mathf.Clamp(localSpacePoint.X, -halfExtents.X, halfExtents.X);
        float y = Mathf.Clamp(localSpacePoint.Y, -halfExtents.Y, halfExtents.Y);
        float z = Mathf.Clamp(localSpacePoint.Z, -halfExtents.Z, halfExtents.Z);

        if((localSpacePoint.X > -halfExtents.X && localSpacePoint.X < halfExtents.X) && 
        (localSpacePoint.Y > -halfExtents.Y && localSpacePoint.Y < halfExtents.Y) &&
        (localSpacePoint.Z > -halfExtents.Z && localSpacePoint.Z < halfExtents.Z))
        {
            float dx = halfExtents.X - Mathf.Abs(localSpacePoint.X);
            float dy = halfExtents.Y - Mathf.Abs(localSpacePoint.Y);
            float dz = halfExtents.Z - Mathf.Abs(localSpacePoint.Z);

            if(dx <= dy && dx <= dz)
                x = Mathf.Sign(localSpacePoint.X) * halfExtents.X;
            else if(dy <= dx && dy <= dz)
                y = Mathf.Sign(localSpacePoint.Y) * halfExtents.Y;
            else
                z = Mathf.Sign(localSpacePoint.Z) * halfExtents.Z;
        }

        localSpacePoint = new Vector3(x, y, z);
        point = unitScale.TransformVector3One(localSpacePoint);
        return point;
    }
}

/// </class>