package scripts;

import com.nolimitscoaster.*;
import nlvm.math3d.*;

import scripts.containers.*;
import scripts.math.*;

/// <class>
/// <desc>Base class to derrive any SceneObject attached scripts.</desc>
public abstract class Behaviour extends Script
{
    private static final List m_Updateables = new List();
    private static Behaviour m_Caller = null;
    private static List m_OrderList = new List(1);

    /// <member>
    /// <desc>Reference to the SceneObject this Behaviour is attached to.</desc>
    /// </member>
    protected SceneObject m_SceneObject = null;
    /// <member>
    /// <desc>The name of the SceneObject.</desc>
    /// </member>
    protected String m_Name = "";

    private float m_PreviousTick = 0.0f;
    private bool m_HasRecievedNextFrameUpdate = false;

    public final bool onInit()
    {
            // The whole reason this exists is because im too lazy to write this
        m_SceneObject = sim.getSceneObjectForEntityId(getParentEntityId());
        if(m_SceneObject == null)
            NullReferenceException.Throw("Unable to find SceneObject, is this Behaviour attached to one?\nCurrently there is no support for non-sceneobject attached scripts");
        m_Name = m_SceneObject.getName();

        if(m_Caller == null)
        {
            m_Caller = this;
            Debug.Print("Behaviour '" + toString() + "' is assigned caller");
        }

        bool isStaying = Awake();
            // If this is the caller and its trying to exit then we need to transfer
        if(isStaying == false && this == m_Caller)
        {
            Debug.Print("Behaviour '" + toString() + "' is caller but is exiting, unassigning caller");
            m_Caller = null;
        }
        if(isStaying == true)
            m_Caller.RegisterOrder(this);

        return isStaying;
    }
    public final bool onLateInit()
    {
            // Skip if not the caller
        if(this != m_Caller)
            return true;
        Debug.Print("Late Start Caller with '" + m_OrderList.Count() + "' behaviours registered");


        IEnumerator enumerator = m_OrderList.GetEnumerator();
        while(enumerator.MoveNext())
        {
            Behaviour behaviour = (Behaviour)enumerator.Get();
            //Debug.Print(behaviour.GetOrder());
            behaviour.Start();
        }

        return true;
    } 
    public final void onNextFrame(float tick)
    {
        Time.DeltaTime = tick;
        Time.PreviousDeltaTime = m_PreviousTick;
        m_PreviousTick = tick;
        Update(tick);

            // Set to true so we know the sim isnt paused and can recieve late update
        m_HasRecievedNextFrameUpdate = true;

        if(m_Caller != this)
            return;
        
            // Loop over the updateables and call their updates
        IEnumerator enumerator = m_Updateables.GetEnumerator();
        while(enumerator.MoveNext())
            ((IUpdateable)enumerator.Get()).Update(tick);
    }
    public final void onLateUpdate()
    {
        if(m_HasRecievedNextFrameUpdate == false)
        {
            LateUnblockedUpdate();

            if(m_Caller != this)
                return;
                
            IEnumerator enumerator = m_Updateables.GetEnumerator();
            while(enumerator.MoveNext())
                ((IUpdateable)enumerator.Get()).LateUnblockedUpdate();

            return;
        }

        m_HasRecievedNextFrameUpdate = false;
        LateUpdate(m_PreviousTick);


        if(m_Caller != this)
            return;
            // Loop over the updateables and call their late updates
        IEnumerator enumerator = m_Updateables.GetEnumerator();
        while(enumerator.MoveNext())
            ((IUpdateable)enumerator.Get()).LateUpdate(m_PreviousTick);
    }
    public final void onExit()
    {
        Destroy();
    }


    protected int GetOrder() { return 0; }
    private void RegisterOrder(Behaviour behaviour)
    {
        if(m_OrderList == null)
            Exception.Throw("Trying to register Behaviour for Start on wrong behaviour");

        Debug.Print("Registering behaviour with order " + behaviour.GetOrder());
        
        if(m_OrderList.Count() == 0)
        {
            m_OrderList.Insert(behaviour);
            return;
        }

        bool success = false;
        for(int i = 0; i < m_OrderList.Count(); i++)
        {
            Behaviour b = (Behaviour)m_OrderList.At(i);
            if(behaviour.GetOrder() <= b.GetOrder())
            {
                m_OrderList.InsertAt(behaviour, i);
                success = true;
                break;
            }
        }

        if(!success)
        {
            m_OrderList.Insert(behaviour);
        }
    }

    /// <method>
    /// <desc>Registers an IUpdateable interface to be called each frame.</desc>
    /// <arg name="updateable">The interface to be registered.</arg>
    /// </method>
    public static final void RegisterUpdateable(IUpdateable updateable)
    {
        if(m_Updateables.Contains(updateable))
            return;
        m_Updateables.Insert(updateable);
    }
    /// <method>
    /// <desc>Removes an IUpdateable interface from the registry.</desc>
    /// <arg name="updateable">The interface to be removed.</arg>
    /// </method>
    public static final void RemoveUpdateable(IUpdateable updateable)
    {
        if(!m_Updateables.Contains(updateable))
            return;
        m_Updateables.Remove(updateable);
    }


    /// <method>
    /// <desc>Called once to initialize the object.</desc>
    /// <return>Pass True to allow it to continue excecution, otherwise False to cancel.</return>
    /// </method>
    public abstract bool Awake();
    /// <method>
    /// <desc>Called once to signify start of update cycle, order can be configured if overriding GetOrder.</desc>
    /// </method>
    public void Start()
    {
    }
    /// <method>
    /// <desc>Called each frame the Behaviour is active.</desc>
    /// <arg name="tick">The time-step the previous frame took to execute.</arg>
    /// </method>
    public void Update(float tick) 
    {
    }
    /// <method>
    /// <desc>Called each frame after Update is called.</desc>
    /// <arg name="tick">The time-step the previous frame took to execute.</arg>
    /// </method>
    public void LateUpdate(float tick)
    {
    }
    /// <method>
    /// <desc>Called each frame unaffected by pausing.</desc>
    /// </method>
    public void LateUnblockedUpdate()
    {
    }
    /// <method>
    /// <desc>Called before this Behaviour is destroyed.</desc>
    /// </method>
    public void Destroy()
    {
    }

    /// <method>
    /// <desc>A String representation of this Behaviour.</desc>
    /// </method>
    public String toString()
    {
        return "Behaviour" + getEntityId();
    }


    public Vector3 GetViewerPosition()
    {
        Vector3f pos = new Vector3f();
        sim.getViewPos(pos);
        return Vector3.FromNative(pos);
    }


    public Vector3 GetPosition()
    {
        return Vector3.FromNative(m_SceneObject.getTranslation());
    }
    public void SetPosition(Vector3 position)
    {
        m_SceneObject.setTranslation(position.GetNative());
    }
    public Vector3 GetScale()
    {
        return Vector3.FromNative(m_SceneObject.getScale());
    }
    public void SetScale(Vector3 scale)
    {
        m_SceneObject.setScale(scale.GetNative());
    }
    public Matrix4x4 GetMatrix()
    {
        return Matrix4x4.FromNative(m_SceneObject.getMatrix());
    }
    public void SetMatrix(Matrix4x4 matrix)
    {
        m_SceneObject.setMatrix(matrix.GetNative());
    }


    /// <method>
    /// <desc>Attempts to retrieve a float parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final float GetFloatParameter(String name)
    {
        Double val = m_SceneObject.getDoubleParameter(name);
        if(val == null)
            NullReferenceException.Throw("Could not find parameter of type 'Double' with name '" + name + "' on SceneObject");
        return val.floatValue();
    }
    /// <method>
    /// <desc>Attempts to retrieve a double parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final double GetDoubleParameter(String name)
    {
        Double val = m_SceneObject.getDoubleParameter(name);
        if(val == null)
            NullReferenceException.Throw("Could not find parameter of type 'Double' with name '" + name + "' on SceneObject");
        return val.doubleValue();
    }
    /// <method>
    /// <desc>Attempts to retrieve a int parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final int GetIntegerParameter(String name)
    {
        Integer val = m_SceneObject.getIntegerParameter(name);
        if (val == null)
            NullReferenceException.Throw("Could not find parameter of type 'Integer' with name '" + name + "' on SceneObject");
        return val.intValue();
    }
    /// <method>
    /// <desc>Attempts to retrieve a String parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final String GetStringParameter(String name)
    {
        String val = m_SceneObject.getStringParameter(name);
        if(val == null)
            NullReferenceException.Throw("Could not find parameter of type 'String' with name '" + name + "' on SceneObject");
        return val;
    }
    /// <method>
    /// <desc>Attempts to retrieve a bool parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final bool GetBoolParameter(String name)
    {
        Boolean val = m_SceneObject.getBooleanParameter(name);
        if(val == null)
            NullReferenceException.Throw("Could not find parameter of type 'Boolean' with name '" + name + "' on SceneObject");
        return val.boolValue();
    }
    /// <method>
    /// <desc>Attempts to retrieve a Coaster parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final Coaster GetCoasterParameter(String name)
    {
        Coaster val = m_SceneObject.getCoasterParameter(name);
        if(val == null)
            NullReferenceException.Throw("Could not find parameter of type 'Coaster' with name '" + name + "' on SceneObject");
        return val;
    }
    /// <method>
    /// <desc>Attempts to retrieve a TrackTrigger parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final TrackTrigger GetTriggerParameter(String name)
    {
        TrackTrigger val = m_SceneObject.getTrackTriggerParameter(name);
        if(val == null)
            NullReferenceException.Throw("Could not find parameter of type 'TrackTrigger' with name '" + name + "' on SceneObject");
        return val;
    }
    /// <method>
    /// <desc>Attempts to retrieve a Block parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final Block GetBlockParameter(String name)
    {
        Block val = m_SceneObject.getBlockParameter(name);
        if(val == null)
            NullReferenceException.Throw("Could not find parameter of type 'BlockSection' with name '" + name + "' on SceneObject");
        return val;
    }
    /// <method>
    /// <desc>Attempts to retrieve a Section parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final Section GetSectionParameter(String name)
    {
        Block val = m_SceneObject.getBlockParameter(name);
        if(val == null)
            NullReferenceException.Throw("Could not find parameter of type 'BlockSection' with name '" + name + "' on SceneObject");   
        return val.getSection();
    }
    /// <method>
    /// <desc>Attempts to retrieve a SpecialTrack parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final SpecialTrack GetSpecialTrackParameter(String name)
    {
        SpecialTrack val = m_SceneObject.getSpecialTrackParameter(name);
        if(val == null)
            NullReferenceException.Throw("COuld not find parameter of type 'SpecialTrack' with name '" + name + "' on SceneObject");   
        return val;
    }
    /// <method>
    /// <desc>Attempts to retrieve a ResourcePath parameter, throws an exception if no parameter is found with the given id.</desc>
    /// <arg name="name">Parameter id.</arg>
    /// </method>
    protected final ResourcePath GetResourcePathParameter(String name)
    {
        ResourcePath val = m_SceneObject.getResourcePathParameter(name);
        if(val == null) 
            NullReferenceException.Throw("Could not find parameter of type 'TextFile | AudioFile | VideoFile | File' with name '" + name + "' on SceneObject");
        return val;
    }

    /// <method>
    /// <desc>Attempts to fetch a SceneObject with a given name.</desc>
    /// <arg name="name">The id of the SceneObject to fetch.</arg>
    /// <arg name="throwIfNotFound">If true, will raise an error if unable to find a SceneObject.</arg>
    /// </method>
    public final SceneObject GetSceneObject(String name, bool throwIfNotFound)
    {
        SceneObject go = sim.getSceneObject(name);
        if(go == null && throwIfNotFound)
            NullReferenceException.Throw("Behaviour: Could not find SceneObject with name '" + name + "'");
        return go;
    }
}
/// </class>