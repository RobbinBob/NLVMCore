package scripts;

//import scripts.math.*;
//import scripts.utilities.*;
import scripts.containers.*;

public class AudioController extends Behaviour implements IReferenceable
{
    private SpatialSound m_PrimaryAudioLoop = null;
    private AudioFile m_PrimaryAudioFile = null;

    private AudioEmitter[] m_GroupEmitters = null;
    private bool m_MutePrimaryTrack = false;
    private bool m_IsEnabled = true;

    private String m_GroupName = "";

    private float m_MuteGain = 0.05f;

    private List m_Queue = new List();

        // Behaviour    
    public int GetOrder() { return -25; }

    public bool Awake()
    {
        return true;
    }

    public void Start()
    {
        Registry registry = Registry.GetInstance();

            // Fetch the main audio loop
        String audioName = GetStringParameter("primary_audio_name");
        if(audioName.length() != 0)
        {
            m_PrimaryAudioFile = (AudioFile)registry.GetReferenceFromName("scripts.AudioFile", GetStringParameter("primary_audio_name"));
            m_PrimaryAudioLoop = (SpatialSound)registry.GetReferenceFromName("scripts.SpatialSound", m_PrimaryAudioFile.GetName());
            if(m_PrimaryAudioLoop == null)
                Exception.Throw("Unable to find scripts.SpatialSound with name '" + GetStringParameter("primary_audio_name") + "'");
        }

            // Fetch the audio group name and register it
        m_GroupName = GetStringParameter("group_name");
        if(m_GroupName == null || m_GroupName.equals(""))
            Exception.Throw("Audio group name is invalid, please make sure to specify a valid name");
        SetName(m_GroupName);

        m_MuteGain = GetFloatParameter("audio_mute_gain");

            // Fetch all AudioEmitters with the same group name
        IReferenceable[] references = registry.GetReferencesFromName("scripts.AudioEmitter", m_GroupName);
        Debug.Print("Found '" + references.length + "' AudioEmitters associated with group '" + m_GroupName + "'");
        m_GroupEmitters = new AudioEmitter[references.length];
        for(int i = 0; i < references.length; ++i)
        {
            m_GroupEmitters[i] = (AudioEmitter)references[i];

            if(m_PrimaryAudioLoop != null)
                m_GroupEmitters[i].CacheAudioClip((SpatialSound)m_PrimaryAudioLoop.Instantiate());
        }

        registry.Register(this);

        if(m_MutePrimaryTrack)
            return;

        for(int i = 0; i < m_GroupEmitters.length; ++i)
        {
            if(m_GroupEmitters[i] == null || m_PrimaryAudioLoop == null)
                continue;

            SpatialSound sound = m_GroupEmitters[i].SetCurrentSound(m_PrimaryAudioLoop.GetName());
            sound.SetGain(m_PrimaryAudioFile.GetDefaultGain());
            sound.SetPitch(m_PrimaryAudioFile.GetDefaultPitch());
            sound.PlaySoundLooped();
        }
    }

    private bool m_Debounce = false;
    private bool m_EnableDebounce = false;
    public void Update(float tick)
    {
        if(m_IsEnabled == false)
        {
            if(m_EnableDebounce)
                return;
            m_EnableDebounce = true;
            for(int i = 0; i < m_GroupEmitters.length; ++i)
            {
                SpatialSound sound;
                if(m_PrimaryAudioLoop != null)
                {
                    sound = m_GroupEmitters[i].SetCurrentSound(m_PrimaryAudioLoop.GetName());
                    sound.SetGain(0);
                }

            }
            IEnumerator enumerator = m_Queue.GetEnumerator();
            while(enumerator.MoveNext())
            {
                AudioConfig audio = (AudioConfig)enumerator.Get();
                DequeueSound(audio.SoundName);
                Debug.Print("Removing sound '" + audio.SoundName + "' from emitter group '" + m_GroupName + "'");
            }
            m_Queue.Clear();
            return;
        }
        else
            m_EnableDebounce = false;

        if(m_Queue.Count() == 0)
        {
            if(!m_Debounce)
            {  
                if(m_PrimaryAudioLoop != null)
                {
                    for(int i = 0; i < m_GroupEmitters.length; ++i)
                    {
                        SpatialSound sound = m_GroupEmitters[i].SetCurrentSound(m_PrimaryAudioLoop.GetName());
                        sound.SetGainFaded(m_MutePrimaryTrack ? 0 : m_PrimaryAudioFile.GetDefaultGain(), 0.5f);
                    }
                }
                m_Debounce = true;
            }
        }
        else
        {
            m_Debounce = false;

                // We need to step through the sounds and find any that are completed, remove them from the queue
            List toRemove = new List();
            IEnumerator enumerator = m_Queue.GetEnumerator();
            while(enumerator.MoveNext())
            {
                AudioConfig audio = (AudioConfig)enumerator.Get();
                SpatialSound sound = m_GroupEmitters[0].SetCurrentSound(audio.SoundName);
                if(sound.IsPlaying() == false)
                    toRemove.Insert(audio);
            }
                // Purge old sounds and set gain to 0 on emitters
            enumerator = toRemove.GetEnumerator();
            while(enumerator.MoveNext())
            {
                Debug.Print("Removing completed sound " + ((AudioConfig)enumerator.Get()).SoundName);
                m_Queue.Remove((AudioConfig)enumerator.Get());
                for(int i = 0; i < m_GroupEmitters.length; ++i)
                {
                    SpatialSound sound = m_GroupEmitters[i].SetCurrentSound(((AudioConfig)enumerator.Get()).SoundName);
                    sound.SetGain(0);
                }
            }




            bool isMutingLower = false;
            for(int i = m_Queue.Count() - 1; i >= 0; --i)
            {
                AudioConfig currentAudio = (AudioConfig)m_Queue.At(i);
                AudioFile currentFile = currentAudio.FileReference;

                for(int j = 0; j < m_GroupEmitters.length; ++j)
                {
                    SpatialSound sound = m_GroupEmitters[j].SetCurrentSound(currentAudio.SoundName);
                    sound.SetGain(!isMutingLower ? currentAudio.FileReference.GetDefaultGain() : 0);
                }
                
                if(currentAudio.CanMuteLowerPriority)
                    isMutingLower = true;
            }

            if(m_PrimaryAudioLoop == null)
                return;
            for(int i = 0; i < m_GroupEmitters.length; ++i)
            {
                SpatialSound sound = m_GroupEmitters[i].SetCurrentSound(m_PrimaryAudioLoop.GetName());
                if(m_MutePrimaryTrack)
                {
                    sound.SetGainFaded(0, 0.5f);
                    return;                
                }
                else
                    sound.SetGainFaded(m_PrimaryAudioFile.GetDefaultGain(), 0.5f);

                if (isMutingLower)
                {
                    sound.SetGainFaded(m_MuteGain, 0.5f);
                }
                else
                {
                    sound.SetGainFaded(m_PrimaryAudioFile.GetDefaultGain(), 0.5f);
                }
            }
        }
    }


    public void EnqueSound(AudioConfig properties)
    {
        if(!m_IsEnabled)
            return;

            // No Audio in queue
        if(m_Queue.Count() == 0)
        {
            m_Queue.Insert(properties);
            for(int i = 0; i < m_GroupEmitters.length; ++i)
            {
                SpatialSound spatialSound = m_GroupEmitters[i].SetCurrentSound(properties.SoundName);
                spatialSound.SetGain(properties.FileReference.GetDefaultGain());
                spatialSound.SetPitch(properties.FileReference.GetDefaultPitch());
                spatialSound.PlaySoundOnce();
            }

            return;
        }

        IEnumerator enumerator = m_Queue.GetEnumerator();
        int index = 0;
        bool success = false;
        while(enumerator.MoveNext())
        {
            AudioConfig sound = (AudioConfig)enumerator.Get();

                // If this is already found in the queue, then we just need to restart it from the beginning
            if(sound.SoundName.equals(properties.SoundName))
            {
                for(int i = 0; i < m_GroupEmitters.length; ++i)
                {
                    SpatialSound spatialSound = m_GroupEmitters[i].SetCurrentSound(properties.SoundName);
                    spatialSound.Stop();
                    spatialSound.PlaySoundOnce();
                }
                return;
            }

                // If this was not found in the queue then we need to begin playing it and add it to the queue
            if(properties.Priority <= sound.Priority)
            {
                m_Queue.InsertAt(properties, index);
                success = true;
                for(int i = 0; i < m_GroupEmitters.length; ++i)
                {
                    SpatialSound spatialSound = m_GroupEmitters[i].SetCurrentSound(properties.SoundName);
                    spatialSound.PlaySoundOnce();
                }

                    // If they both equal the same property then we need to remove the old audio
                while(properties.Priority == ((AudioConfig)enumerator.Get()).Priority)
                {
                    DequeueSound(((AudioConfig)enumerator.Get()).SoundName);
                    if(!enumerator.MoveNext())
                        break;
                }

                break;
            }
        }

            // If it was unsuccessful at adding this new audio clip to the queue (usually occurs from an empty queue)
        if(!success)
        {
            m_Queue.Insert(properties);
            for(int i = 0; i < m_GroupEmitters.length; ++i)
            {
                SpatialSound spatialSound = m_GroupEmitters[i].SetCurrentSound(properties.SoundName);
                spatialSound.PlaySoundOnce();
            }
        }
    }
    public void DequeueSound(String soundName)
    {
        if(m_Queue.Count() == 0)
            return;

        IEnumerator enumerator = m_Queue.GetEnumerator();
        int i = 0;
        while(enumerator.MoveNext())
        {
            AudioConfig sound = (AudioConfig)enumerator.Get();
            if(!sound.SoundName.equals(soundName))
            {
                i++;
                continue;
            }

            Debug.Print("Found sound with name '" + soundName + "' stopping sound and removing it from queue");
            for(int j = 0; j < m_GroupEmitters.length; ++j)
            {
                SpatialSound spatialSound = m_GroupEmitters[j].SetCurrentSound(sound.SoundName);
                spatialSound.Stop();
            }

            m_Queue.RemoveAt(i);
            break;
        }
    }
    
    
    public void SetPrimaryTrackMuted(bool isMuted)
    {
        m_MutePrimaryTrack = isMuted;
        if(m_PrimaryAudioLoop == null)
            return;

        for(int i = 0; i < m_GroupEmitters.length; ++i)
        {
            SpatialSound sound = m_GroupEmitters[i].SetCurrentSound(m_PrimaryAudioLoop.GetName());
            if(m_IsEnabled)
                sound.SetGainFaded(m_MutePrimaryTrack ? 0 : m_PrimaryAudioFile.GetDefaultGain(), 0.5f);
        }
    }
    public void SetControllerOn(bool isEnabled)
    {
        m_IsEnabled = isEnabled;
        if(m_PrimaryAudioLoop != null)
        {
            for(int i = 0; i < m_GroupEmitters.length; ++i)
            {
                SpatialSound sound;
                sound = m_GroupEmitters[i].SetCurrentSound(m_PrimaryAudioLoop.GetName());
                sound.SetGain(m_IsEnabled ? m_PrimaryAudioFile.GetDefaultGain() : 0);
            }
        }

        if(m_IsEnabled)
            SetPrimaryTrackMuted(m_MutePrimaryTrack);
    }

        // IReferenceable
    public String GetType()
    {
        return "scripts.AudioController";
    }
    public String GetName()
    {
        return m_Name;
    }
    public void SetName(String string)
    {
        m_Name = string;
    }
}